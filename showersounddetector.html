<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shower Sound Detector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background: #e0f7fa;
            padding: 2rem;
        }
        
        h1 {
            color: #0066cc;
        }
        
        #status {
            font-size: 1.5rem;
            margin: 1rem 0;
            color: #333;
        }
        
        #usage {
            font-size: 1.2rem;
            margin: 1rem 0;
            color: #666;
        }
        
        .button {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 0.5rem;
        }
        
        #start-btn {
            background: #0066cc;
        }
        
        #start-btn:hover {
            background: #004a99;
        }
        
        #stop-btn {
            background: #cc0000;
            display: none;
        }
        
        #stop-btn:hover {
            background: #990000;
        }
    </style>
</head>

<body>
    <h1>Shower Sound Detector</h1>
    <p>Click the button and allow microphone access.</p>
    <button id="start-btn" class="button">Start Listening</button>
    <button id="stop-btn" class="button">Stop Listening</button>
    <div id="status">Waiting...</div>
    <div id="usage"></div>

    <script>
        // Constants
        const FS = 48000; // Sample rate [Hz]
        const FRAME_MS = 200; // Analysis window [ms]
        const N_SAMPLES = Math.round(FRAME_MS / 1000 * FS);
        const HPF_CUTOFF_HZ = 1000; // High-pass corner
        const DB_THRESHOLD = -60.0; // Loudness cut-off [dBFS]
        const FLAT_THRESHOLD = 0.35; // Flatness cut-off
        const DEBOUNCE_MS = 1000; // Min stable time to flip state
        const L_PER_MIN = 9.0; // Shower-head flow [L/min]
        const EPSILON = 1e-10; // Small number to avoid division by zero

        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const status = document.getElementById('status');
        const usage = document.getElementById('usage');

        // State variables
        let showerState = false;
        let stableDuration = 0;
        let usageSeconds = 0;
        let lastUiUpdate = Date.now();
        let audioContext;
        let analyser;
        let kCut;
        let mBins;
        let mediaStream;
        let isProcessing = false;

        startBtn.addEventListener('click', async() => {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: true
                });
                audioContext = new AudioContext({
                    sampleRate: FS
                });
                const source = audioContext.createMediaStreamSource(mediaStream);

                // Create high-pass filter
                const hpf = audioContext.createBiquadFilter();
                hpf.type = 'highpass';
                hpf.frequency.value = HPF_CUTOFF_HZ;

                // Create analyzer
                analyser = audioContext.createAnalyser();
                analyser.fftSize = Math.pow(2, Math.ceil(Math.log2(N_SAMPLES)));
                analyser.smoothingTimeConstant = 0;

                // Connect nodes
                source.connect(hpf);
                hpf.connect(analyser);

                // Calculate frequency bin cutoff
                kCut = Math.ceil(HPF_CUTOFF_HZ * analyser.fftSize / FS);
                mBins = analyser.frequencyBinCount - kCut;

                // Update UI
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-block';
                isProcessing = true;

                // Start processing
                detectShowerNoise();
            } catch (err) {
                status.textContent = 'Microphone access denied or unavailable.';
                status.style.color = 'red';
            }
        });

        stopBtn.addEventListener('click', () => {
            stopProcessing();
        });

        function stopProcessing() {
            isProcessing = false;

            // Stop all audio tracks
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }

            // Close audio context
            if (audioContext) {
                audioContext.close();
            }

            // Reset state
            showerState = false;
            stableDuration = 0;

            // Update UI
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            status.textContent = 'Stopped';
            status.style.color = '#333';
            usage.textContent = '';
        }

        function detectShowerNoise() {
            if (!isProcessing) return;

            const freqBuf = new Float32Array(analyser.frequencyBinCount);
            const timeBuf = new Uint8Array(N_SAMPLES);

            analyser.getFloatFrequencyData(freqBuf);
            analyser.getByteTimeDomainData(timeBuf);

            // Feature extraction over â‰¥1 kHz bins
            let pSumLin = 0;
            let logPSum = 0;

            for (let k = kCut; k < analyser.frequencyBinCount; k++) {
                const pLin = Math.pow(10, freqBuf[k] / 10); // dB â†’ linear power
                pSumLin += pLin;
                logPSum += Math.log(pLin + EPSILON);
            }

            const geoMean = Math.exp(logPSum / mBins);
            const arithMean = pSumLin / mBins;
            const flatness = geoMean / (arithMean + EPSILON);

            // Calculate RMS in dBFS
            const rmsLin = Math.sqrt(pSumLin / mBins);
            const loudnessDb = 20 * Math.log10(rmsLin + EPSILON);

            // Instantaneous decision
            const decision = (loudnessDb > DB_THRESHOLD) && (flatness > FLAT_THRESHOLD);

            // Debounce logic
            if (decision === showerState) {
                stableDuration = 0;
            } else {
                stableDuration += FRAME_MS;
                if (stableDuration >= DEBOUNCE_MS) {
                    showerState = decision;
                    stableDuration = 0;
                }
            }

            // Accumulate usage
            if (showerState) {
                usageSeconds += FRAME_MS / 1000;
            }

            // Update UI periodically
            const now = Date.now();
            if (now - lastUiUpdate > 2000) {
                updateDisplay();
                persistUsage();
                lastUiUpdate = now;
            }

            requestAnimationFrame(detectShowerNoise);
        }

        function updateDisplay() {
            if (showerState) {
                status.textContent = 'ðŸš¿ Shower ON';
                status.style.color = 'green';
            } else {
                status.textContent = 'Shower off';
                status.style.color = '#333';
            }

            const minutes = usageSeconds / 60;
            const litres = (usageSeconds / 60) * L_PER_MIN;
            usage.textContent = `${minutes.toFixed(1)} min â‰ˆ ${litres.toFixed(1)} L`;
        }

        function persistUsage() {
            const today = new Date().toISOString().split('T')[0];
            localStorage.setItem(today, usageSeconds.toString());
        }
    </script>
</body>

</html>